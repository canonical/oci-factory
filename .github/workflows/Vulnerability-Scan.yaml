name: Vulnerability Scan
run-name: 'Tests - ${{ inputs.oci-image-name }} - ${{ github.ref }}'

on:
  workflow_call:
    inputs:
      oci-image-name:
        description: 'Name of the image to be fetched and tested'
        required: true
        type: string
      oci-image-path:
        description: 'Path to the image in this repo (eg. "oci/foo")'
        required: true
        type: string
      cache-key:
        description: 'Key ID for restoring image (in OCI format) from cache'
        required: false
        type: string
        default: ''
      vulnerability-report-suffix:
        description: 'Suffix for the vulnerability report artefact'
        required: false
        type: string
        default: '.vulnerability-report.json'
      date-last-scan:
        description: 'If there are new CVEs after this date, we notify'
        required: false
        type: string
        default: '9999-12-31T23:59:59'
    outputs:
      vulnerabilities:
        description: "Result of the vulnerability analysis."
        value: ${{ jobs.test-vulnerabilities.outputs.vulnerabilities }}
      notify:
        description: "Should we report result to issue tracker?"
        value: ${{ jobs.test-vulnerabilities.outputs.notify }}

env:
  TEST_IMAGE_NAME: 'test-img'
  TEST_IMAGE_TAG: 'test'
  SKOPEO_IMAGE: 'quay.io/skopeo/stable:v1.15.1'
  TRIVY_DB_REPOSITORY: public.ecr.aws/aquasecurity/trivy-db,aquasec/trivy-db,ghcr.io/aquasecurity/trivy-db
  TRIVY_JAVA_DB_REPOSITORY: public.ecr.aws/aquasecurity/trivy-java-db,aquasec/trivy-java-db,ghcr.io/aquasecurity/trivy-java-db

jobs:
  test-vulnerabilities:
    runs-on: ubuntu-22.04
    name: Vulnerability scan
    outputs:
      vulnerability-report: ${{ steps.vulnerability-report.outputs.name }}
      notify: ${{ steps.check-report.outputs.notify }}
      vulnerabilities: ${{ steps.check-report.outputs.vulnerabilities }}
    steps:
      - uses: actions/checkout@v4

      - name: Validate access to triggered image
        uses: ./.github/actions/validate-actor
        if: ${{ github.repository == 'canonical/oci-factory' && !github.event.pull_request.head.repo.fork }}
        with:
          admin-only: true
          image-path: ${{ inputs.oci-image-path }}
          github-token: ${{ secrets.ROCKSBOT_TOKEN }}

      - id: vulnerability-report
        run: |
          full_name="${{ inputs.oci-image-name }}${{ inputs.vulnerability-report-suffix }}"
          final_name="$(echo ${full_name} | sed 's/ghcr.io\/canonical\/oci-factory\///g' | tr ':' '_')"
          echo "name=$final_name" >> "$GITHUB_OUTPUT" 

      - uses: actions/cache/restore@v4
        if: ${{ inputs.cache-key != '' }}
        with:
          path: ${{ env.TEST_IMAGE_NAME}}
          key: ${{ inputs.cache-key }}
          fail-on-cache-miss: true
      
      - name: Copy image to Docker daemon
        id: to-docker-daemon
        run: |
          d_img_name="${{ env.TEST_IMAGE_NAME}}:${{ env.TEST_IMAGE_TAG }}"
          echo "name=$d_img_name" >> "$GITHUB_OUTPUT"
          if [[ "${{ inputs.cache-key}}" != "" ]]
          then
            source=oci:${{ env.TEST_IMAGE_NAME}} 
          else
            source=docker://${{ inputs.oci-image-name }}
          fi
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $PWD:/workdir -w /workdir \
            ${{ env.SKOPEO_IMAGE }} \
            copy $source \
            docker-daemon:$d_img_name

      - name: Check for .trivyignore
        id: trivyignore
        run: |
          if [ -f ${{ inputs.oci-image-path }}/.trivyignore ]
          then
            file=${{ inputs.oci-image-path }}/.trivyignore
          else
            # dummy .trivyignore file
            file=.trivyignore
            touch $file
          fi
          echo "file=$file" >> "$GITHUB_OUTPUT"

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@0.28.0
        with:
          # NOTE: we're allowing images with vulnerabilities to be published
          ignore-unfixed: true
          trivyignores: ${{ steps.trivyignore.outputs.file }}
          format: 'cosign-vuln'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          # NOTE: pebble is flagged with a HIGH vuln because of golang.org/x/crypto
          # CVE-2021-43565, CVE-2022-27191
          skip-files: /bin/pebble
          # missing ${{ runner.arch }}
          output: '${{ steps.vulnerability-report.outputs.name }}'
          image-ref: '${{ steps.to-docker-daemon.outputs.name }}'

      - name: Process report
        if: ${{ !cancelled() }}
        id: check-report
        run: |
          report="${{ steps.vulnerability-report.outputs.name }}"
          echo "notify=false" >> "$GITHUB_OUTPUT"
          set -x
          vulnerabilities="$(jq -r -c '[
                  try(.scanner.result.Results[])
                  | .Target as $target
                  | .Vulnerabilities
                  | select(. != null)
                  | .[]
                  | {Target: $target, LastModifiedDate: .LastModifiedDate, VulnerabilityID: .VulnerabilityID,
                     PkgName: .PkgName, Severity: .Severity}
                ]' < $report)"
          echo "vulnerabilities=$vulnerabilities" >> "$GITHUB_OUTPUT"
          last_modified_dates="$(echo "$vulnerabilities" | jq -r '.[] | select(.LastModifiedDate != null) | .LastModifiedDate')"
          cat "$GITHUB_OUTPUT"
          # We want to notify only if the CVEs have been updated since the last
          # time this scan ran
          for cve_updated in $last_modified_dates
          do
            if [[ "$cve_updated" > "${{ inputs.date-last-scan }}" ]]
            then
              echo "notify=true" >> "$GITHUB_OUTPUT"
              break
            fi
          done

      - uses: actions/cache/save@v4
        if: ${{ !cancelled() }}
        with:
          path: ${{ steps.vulnerability-report.outputs.name }}
          key: ${{ github.run_id }}-${{ steps.vulnerability-report.outputs.name }}

      - uses: actions/upload-artifact@v4
        if: ${{ !cancelled() }}
        with:
          name: ${{ steps.vulnerability-report.outputs.name }}
          path: ${{ steps.vulnerability-report.outputs.name }}


  # Many workflows are now using a similar notification job. It would be better
  # if this was a common workflows reachable via a workflow_call
  notify:
    runs-on: ubuntu-22.04
    name: Notify on failure
    needs:
      - test-vulnerabilities
    if: ${{ !cancelled() && needs.test-vulnerabilities.outputs.notify == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Get contacts for ${{ inputs.oci-image-name }}
        id: get-contacts
        working-directory: ${{ inputs.oci-image-path }}
        run: |
          mm_channels=$(yq -r '.notify | ."mattermost-channels" | join(",")' < contacts.y*ml)
          echo "mattermost-channels=${mm_channels}" >> "$GITHUB_OUTPUT"

      - name: Notify via Mattermost
        env:
          MM_BOT_TOKEN: ${{ secrets.MM_BOT_TOKEN }}
          FINAL_STATUS: failure
          MM_SERVER: ${{ secrets.MM_SERVER }}
          URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SUMMARY: ''
          FOOTER: ''
          TITLE: 'Vulnerabilities found for ${{ inputs.oci-image-name }}'
        run: |
          for channel in $(echo ${{ steps.get-contacts.outputs.mattermost-channels }} | tr ',' ' ')
          do
            MM_CHANNEL_ID="${channel}" ./src/notifications/send_to_mattermost.sh
          done
